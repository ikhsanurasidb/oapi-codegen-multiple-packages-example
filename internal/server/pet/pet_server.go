// Package pet provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package pet

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Add a new pet to the store
	// (POST /pet)
	AddPet(c *gin.Context)
	// Update an existing pet
	// (PUT /pet)
	UpdatePet(c *gin.Context)
	// Finds Pets by status
	// (GET /pet/findByStatus)
	FindPetsByStatus(c *gin.Context, params FindPetsByStatusParams)
	// Finds Pets by tags
	// (GET /pet/findByTags)
	FindPetsByTags(c *gin.Context, params FindPetsByTagsParams)
	// Deletes a pet
	// (DELETE /pet/{petId})
	DeletePet(c *gin.Context, petId int64, params DeletePetParams)
	// Find pet by ID
	// (GET /pet/{petId})
	GetPetById(c *gin.Context, petId int64)
	// Updates a pet in the store with form data
	// (POST /pet/{petId})
	UpdatePetWithForm(c *gin.Context, petId int64, params UpdatePetWithFormParams)
	// uploads an image
	// (POST /pet/{petId}/uploadImage)
	UploadFile(c *gin.Context, petId int64, params UploadFileParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// AddPet operation middleware
func (siw *ServerInterfaceWrapper) AddPet(c *gin.Context) {

	c.Set(Petstore_authScopes, []string{"write:pets", "read:pets"})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.AddPet(c)
}

// UpdatePet operation middleware
func (siw *ServerInterfaceWrapper) UpdatePet(c *gin.Context) {

	c.Set(Petstore_authScopes, []string{"write:pets", "read:pets"})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdatePet(c)
}

// FindPetsByStatus operation middleware
func (siw *ServerInterfaceWrapper) FindPetsByStatus(c *gin.Context) {

	var err error

	c.Set(Petstore_authScopes, []string{"write:pets", "read:pets"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindPetsByStatusParams

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", c.Request.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter status: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FindPetsByStatus(c, params)
}

// FindPetsByTags operation middleware
func (siw *ServerInterfaceWrapper) FindPetsByTags(c *gin.Context) {

	var err error

	c.Set(Petstore_authScopes, []string{"write:pets", "read:pets"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindPetsByTagsParams

	// ------------- Optional query parameter "tags" -------------

	err = runtime.BindQueryParameter("form", true, false, "tags", c.Request.URL.Query(), &params.Tags)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter tags: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.FindPetsByTags(c, params)
}

// DeletePet operation middleware
func (siw *ServerInterfaceWrapper) DeletePet(c *gin.Context) {

	var err error

	// ------------- Path parameter "petId" -------------
	var petId int64

	err = runtime.BindStyledParameterWithOptions("simple", "petId", c.Param("petId"), &petId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter petId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(Petstore_authScopes, []string{"write:pets", "read:pets"})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeletePetParams

	headers := c.Request.Header

	// ------------- Optional header parameter "api_key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("api_key")]; found {
		var ApiKey string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for api_key, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "api_key", valueList[0], &ApiKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter api_key: %w", err), http.StatusBadRequest)
			return
		}

		params.ApiKey = &ApiKey

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeletePet(c, petId, params)
}

// GetPetById operation middleware
func (siw *ServerInterfaceWrapper) GetPetById(c *gin.Context) {

	var err error

	// ------------- Path parameter "petId" -------------
	var petId int64

	err = runtime.BindStyledParameterWithOptions("simple", "petId", c.Param("petId"), &petId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter petId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(Api_keyScopes, []string{})

	c.Set(Petstore_authScopes, []string{"write:pets", "read:pets"})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetPetById(c, petId)
}

// UpdatePetWithForm operation middleware
func (siw *ServerInterfaceWrapper) UpdatePetWithForm(c *gin.Context) {

	var err error

	// ------------- Path parameter "petId" -------------
	var petId int64

	err = runtime.BindStyledParameterWithOptions("simple", "petId", c.Param("petId"), &petId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter petId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(Petstore_authScopes, []string{"write:pets", "read:pets"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdatePetWithFormParams

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", c.Request.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", c.Request.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter status: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdatePetWithForm(c, petId, params)
}

// UploadFile operation middleware
func (siw *ServerInterfaceWrapper) UploadFile(c *gin.Context) {

	var err error

	// ------------- Path parameter "petId" -------------
	var petId int64

	err = runtime.BindStyledParameterWithOptions("simple", "petId", c.Param("petId"), &petId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter petId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(Petstore_authScopes, []string{"write:pets", "read:pets"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UploadFileParams

	// ------------- Optional query parameter "additionalMetadata" -------------

	err = runtime.BindQueryParameter("form", true, false, "additionalMetadata", c.Request.URL.Query(), &params.AdditionalMetadata)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter additionalMetadata: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UploadFile(c, petId, params)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.POST(options.BaseURL+"/pet", wrapper.AddPet)
	router.PUT(options.BaseURL+"/pet", wrapper.UpdatePet)
	router.GET(options.BaseURL+"/pet/findByStatus", wrapper.FindPetsByStatus)
	router.GET(options.BaseURL+"/pet/findByTags", wrapper.FindPetsByTags)
	router.DELETE(options.BaseURL+"/pet/:petId", wrapper.DeletePet)
	router.GET(options.BaseURL+"/pet/:petId", wrapper.GetPetById)
	router.POST(options.BaseURL+"/pet/:petId", wrapper.UpdatePetWithForm)
	router.POST(options.BaseURL+"/pet/:petId/uploadImage", wrapper.UploadFile)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
